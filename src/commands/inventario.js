// inventario.js - Com exibiÃ§Ã£o detalhada de itens
import {
  SlashCommandBuilder,
  EmbedBuilder,
  ActionRowBuilder,
  ButtonBuilder,
  ButtonStyle,
  StringSelectMenuBuilder,
  ComponentType,
} from "discord.js";
import inventoryService from "../services/inventory.js";
import storeItemsService from "../services/store-items.js";
import embedUtils from "../utils/embed.js";
import { formatarDinheiro, formatarTempoEspera } from "../utils/format.js";

export const data = new SlashCommandBuilder()
  .setName("inventario")
  .setDescription("Mostra os itens em seu inventÃ¡rio")
  .addUserOption((option) =>
    option
      .setName("usuario")
      .setDescription("UsuÃ¡rio para ver o inventÃ¡rio (opcional)")
      .setRequired(false)
  )
  .addStringOption((option) =>
    option
      .setName("categoria")
      .setDescription("Categoria especÃ­fica de itens para visualizar")
      .setRequired(false)
      .addChoices(
        { name: "ðŸŽ° Cassino", value: "casino" },
        { name: "ðŸ§ª ConsumÃ­veis", value: "consumiveis" },
        { name: "âœ¨ VIP", value: "vip" },
        { name: "ðŸ“¦ Todos os Itens", value: "all" }
      )
  );

export async function execute(interaction) {
  try {
    await interaction.deferReply();

    // Verifica se foi especificado um usuÃ¡rio ou usa o autor do comando
    const targetUser =
      interaction.options.getUser("usuario") || interaction.user;
    const userId = targetUser.id;
    const isOwnInventory = targetUser.id === interaction.user.id;

    // Categoria selecionada (se houver)
    const selectedCategory =
      interaction.options.getString("categoria") || "all";

    // Obter inventÃ¡rio do usuÃ¡rio
    const inventory = await inventoryService.getUserInventory(userId);

    if (!inventory) {
      const embedErro = embedUtils.criarEmbedErro({
        usuario: interaction.user.username,
        titulo: "InventÃ¡rio NÃ£o Encontrado",
        mensagem: `NÃ£o foi possÃ­vel encontrar o inventÃ¡rio ${
          isOwnInventory ? "do seu usuÃ¡rio" : "deste usuÃ¡rio"
        }.`,
      });

      return interaction.editReply({ embeds: [embedErro] });
    }

    // Obter a quantidade de fichas de cassino
    const casinoChips = inventory.fichas_cassino || 0;

    // Criar embed do inventÃ¡rio
    const embed = new EmbedBuilder()
      .setColor(0x0099ff) // Azul
      .setTitle(`ðŸŽ’ InventÃ¡rio de ${targetUser.username}`)
      .setThumbnail(targetUser.displayAvatarURL({ dynamic: true }));

    // Adicionar descriÃ§Ã£o explicativa
    let description = isOwnInventory
      ? "Aqui estÃ¡ o seu inventÃ¡rio de itens. Use os botÃµes abaixo para navegar."
      : `Aqui estÃ¡ o inventÃ¡rio de ${targetUser.username}.`;

    if (selectedCategory !== "all") {
      description += `\nFiltrando pela categoria: **${storeItemsService.getCategoryDisplayName(
        selectedCategory
      )}**`;
    }

    embed.setDescription(description);

    // Adicionar informaÃ§Ãµes das fichas de cassino
    if (selectedCategory === "all" || selectedCategory === "casino") {
      embed.addFields({
        name: "ðŸŽ° Fichas de Cassino",
        value: `${casinoChips} fichas`,
        inline: true,
      });

      // Adicionar valor estimado
      embed.addFields({
        name: "ðŸ’¸ Valor Estimado",
        value: formatarDinheiro(casinoChips * 10),
        inline: true,
      });
    }

    // Processar itens do inventÃ¡rio
    let hasItems = false;
    console.log(
      `Processando inventÃ¡rio. Categoria selecionada: ${selectedCategory}`
    );
    console.log("Itens no inventÃ¡rio:", inventory.items);

    let itemsByCategory = {};
    if (inventory.items && Object.keys(inventory.items).length > 0) {
      // Agrupar itens por categoria
      // Processar cada item no inventÃ¡rio
      for (const itemId in inventory.items) {
        console.log(
          `Verificando item: ${itemId}, Quantidade: ${inventory.items[itemId].quantity}`
        );

        // Verificar se o item existe e tem quantidade maior que 0
        if (inventory.items[itemId].quantity <= 0) {
          console.log(`Item ${itemId} tem quantidade 0, pulando`);
          continue;
        }

        // Obter detalhes do item da loja
        const itemDetails = storeItemsService.getItemById(itemId);
        console.log("Detalhes do item:", itemDetails);

        if (!itemDetails) {
          console.log(`Item ${itemId} nÃ£o encontrado na loja, pulando`);
          continue;
        }

        // Filtrar por categoria selecionada
        if (
          selectedCategory !== "all" &&
          itemDetails.category !== selectedCategory
        ) {
          console.log(
            `Item ${itemId} nÃ£o pertence Ã  categoria ${selectedCategory}, pulando`
          );
          continue;
        }

        // Inicializar categoria se necessÃ¡rio
        if (!itemsByCategory[itemDetails.category]) {
          itemsByCategory[itemDetails.category] = [];
        }

        // Adicionar item Ã  categoria
        itemsByCategory[itemDetails.category].push({
          id: itemId,
          name: itemDetails.name,
          icon: itemDetails.icon,
          quantity: inventory.items[itemId].quantity,
          description: itemDetails.description,
          usavel: itemDetails.usavel,
          lastUsed: inventory.items[itemId].lastUsed,
        });

        hasItems = true;
      }
      console.log("Itens agrupados por categoria:", itemsByCategory);
    }

    // Adicionar campos ao embed para cada categoria de item
    for (const category in itemsByCategory) {
      // Obter nome de exibiÃ§Ã£o e Ã­cone da categoria
      const categoryDisplayName =
        storeItemsService.getCategoryDisplayName(category);

      // Formatar itens desta categoria
      const itemsText = itemsByCategory[category]
        .map((item) => {
          // Verificar se estÃ¡ em cooldown
          let cooldownText = "";
          let statusIcon = "";

          if (item.lastUsed && item.usavel) {
            const now = Date.now();
            const timeElapsed = now - item.lastUsed;

            // Obter detalhes do item da loja para verificar cooldown
            const storeItem = storeItemsService.getItemById(item.id);
            if (
              storeItem &&
              storeItem.cooldown &&
              timeElapsed < storeItem.cooldown
            ) {
              const timeRemaining = storeItem.cooldown - timeElapsed;
              cooldownText = ` (ðŸ•’ Em espera: ${formatarTempoEspera(
                timeRemaining
              )})`;
              statusIcon = "ðŸ•’";
            } else if (
              storeItem &&
              storeItem.duration &&
              timeElapsed < storeItem.duration
            ) {
              // Item ainda estÃ¡ ativo
              const timeRemaining = storeItem.duration - timeElapsed;
              cooldownText = ` (âœ¨ Ativo por mais: ${formatarTempoEspera(
                timeRemaining
              )})`;
              statusIcon = "âœ¨";
            } else {
              statusIcon = item.usavel ? "âœ…" : "ðŸ“¦";
            }
          } else {
            statusIcon = item.usavel ? "âœ…" : "ðŸ“¦";
          }

          return `${statusIcon} **${item.icon} ${item.name}** x${item.quantity}${cooldownText}\nâ”” *${item.description}*`;
        })
        .join("\n\n");

      // Adicionar campo para esta categoria
      embed.addFields({
        name: `${storeItemsService.getCategoryIcon(
          category
        )} ${categoryDisplayName} (${itemsByCategory[category].length})`,
        value: itemsText || "Nenhum item nesta categoria.",
        inline: false,
      });
    }

    // Verificar se o usuÃ¡rio tem algum item (alÃ©m das fichas)
    if (!hasItems) {
      const noItemsMessage = isOwnInventory
        ? "VocÃª nÃ£o possui nenhum item em seu inventÃ¡rio. Use o comando `/loja` para comprar itens!"
        : `${targetUser.username} nÃ£o possui nenhum item em seu inventÃ¡rio.`;

      embed.addFields({
        name: "ðŸ“¦ InventÃ¡rio vazio",
        value: noItemsMessage,
        inline: false,
      });
    }

    // Criar botÃµes para aÃ§Ãµes rÃ¡pidas
    const row = new ActionRowBuilder();

    // Sempre adicionar botÃ£o para a loja
    if (isOwnInventory) {
      row.addComponents(
        new ButtonBuilder()
          .setCustomId("go_to_shop")
          .setLabel("Comprar Itens")
          .setStyle(ButtonStyle.Primary)
          .setEmoji("ðŸ›’")
      );
    }

    // Adicionar botÃ£o para trocar fichas por dinheiro apenas se tiver fichas
    if (casinoChips > 0 && isOwnInventory) {
      row.addComponents(
        new ButtonBuilder()
          .setCustomId("exchange_chips")
          .setLabel("Trocar Fichas")
          .setStyle(ButtonStyle.Success)
          .setEmoji("ðŸ’±")
      );
    }

    // Adicionar botÃ£o para usar item se tiver itens usÃ¡veis e for o prÃ³prio inventÃ¡rio
    if (hasItems && isOwnInventory) {
      row.addComponents(
        new ButtonBuilder()
          .setCustomId("use_item")
          .setLabel("Usar Item")
          .setStyle(ButtonStyle.Danger)
          .setEmoji("ðŸ”®")
      );
    }

    // Criar menu para filtrar categorias
    const filterMenu = new ActionRowBuilder().addComponents(
      new StringSelectMenuBuilder()
        .setCustomId("filter_category")
        .setPlaceholder("Filtrar por categoria...")
        .addOptions([
          {
            label: "Todos os Itens",
            value: "all",
            description: "Mostrar todo o inventÃ¡rio",
            emoji: "ðŸ“¦",
            default: selectedCategory === "all",
          },
          {
            label: "Fichas de Cassino",
            value: "casino",
            description: "Mostrar apenas fichas de cassino",
            emoji: "ðŸŽ°",
            default: selectedCategory === "casino",
          },
          {
            label: "ConsumÃ­veis",
            value: "consumiveis",
            description: "Mostrar apenas itens consumÃ­veis",
            emoji: "ðŸ§ª",
            default: selectedCategory === "consumiveis",
          },
          {
            label: "VIP",
            value: "vip",
            description: "Mostrar apenas itens VIP",
            emoji: "âœ¨",
            default: selectedCategory === "vip",
          },
        ])
    );

    // Enviar a mensagem
    const components = [];
    if (row.components.length > 0) {
      components.push(row);
    }
    components.push(filterMenu);

    const reply = await interaction.editReply({
      embeds: [embed],
      components: components,
    });

    // Coletor para botÃµes e menus
    const collector = reply.createMessageComponentCollector({
      time: 60000, // 1 minuto
    });

    collector.on("collect", async (i) => {
      if (i.user.id !== interaction.user.id) {
        await i.reply({
          content: "VocÃª nÃ£o pode usar estes controles.",
          ephemeral: true,
        });
        return;
      }

      // Processar interaÃ§Ãµes de botÃµes
      if (i.isButton()) {
        if (i.customId === "go_to_shop") {
          await i.reply({
            content:
              "Use o comando `/loja` para comprar fichas de cassino e outros itens!",
            ephemeral: true,
          });
        } else if (i.customId === "exchange_chips") {
          await i.reply({
            content:
              "Use o comando `/trocar-fichas [quantidade]` para trocar suas fichas por dinheiro!",
            ephemeral: true,
          });
        } else if (i.customId === "use_item") {
          await i.reply({
            content:
              "Use o comando `/usar [item]` para utilizar um item do seu inventÃ¡rio!",
            ephemeral: true,
          });
        }
      }
      // Processar interaÃ§Ãµes de menu de seleÃ§Ã£o
      else if (i.isStringSelectMenu() && i.customId === "filter_category") {
        const newCategory = i.values[0];
        await i.deferUpdate();

        // Criar uma nova interaÃ§Ã£o com a categoria selecionada
        const newInteraction = {
          ...interaction,
          options: {
            ...interaction.options,
            getString: (name) => {
              if (name === "categoria") return newCategory;
              return interaction.options.getString(name);
            },
            getUser: (name) => interaction.options.getUser(name),
          },
          deferReply: async () => {},
          editReply: i.editReply.bind(i),
        };

        // Executar novamente com a nova categoria
        await execute(newInteraction);
        collector.stop();
      }
    });

    try {
      collector.on("end", async (collected, reason) => {
        if (reason === "time") {
          // Desativar componentes quando expirar
          const disabledComponents = components.map((row) => {
            const disabledRow = new ActionRowBuilder();

            row.components.forEach((component) => {
              if (component.type === ComponentType.Button) {
                disabledRow.addComponents(
                  ButtonBuilder.from(component).setDisabled(true)
                );
              } else if (component.type === ComponentType.StringSelect) {
                disabledRow.addComponents(
                  StringSelectMenuBuilder.from(component)
                    .setDisabled(true)
                    .setPlaceholder("Menu expirado")
                );
              }
            });

            return disabledRow;
          });

          try {
            await interaction.editReply({ components: disabledComponents });
          } catch (editError) {
            console.error("Erro ao editar resposta:", editError);
          }
        }
      });
    } catch (error) {
      console.error("Erro ao executar coletor do comando inventario:", error);

      const embedErro = embedUtils.criarEmbedErro({
        usuario: interaction.user.username,
        titulo: "Erro no Comando",
        mensagem:
          "Ocorreu um erro ao processar o comando. Tente novamente mais tarde.",
      });

      return interaction.editReply({ embeds: [embedErro] });
    }
  } catch (error) {
    console.error("Erro ao executar comando inventario:", error);

    const embedErro = embedUtils.criarEmbedErro({
      usuario: interaction.user.username,
      titulo: "Erro no Comando",
      mensagem:
        "Ocorreu um erro ao processar o comando. Tente novamente mais tarde.",
    });

    return interaction.editReply({ embeds: [embedErro] });
  }
}
